---
layout: post
title: Android Clock 源码分析
categories: Android系统
description: 梳理Clock，以及功能实现和修改方式
keywords: Android系统

---

梳理Clock，以及功能实现和修改方式

# Android Clock —— DeskClock
　　系统中一般使用的都是google原生时钟，即DeskClock，位于目录*package/app/DeskClock/*。
  
  
### 功能界面和设置界面 
<img src="/images/clock_main.png" width="24%" alt="clock主界面" />
<img src="/images/clock_settings_01.png" width="24%" alt="clock设置界面01" />
<img src="/images/clock_settings_02.png" width="24%" alt="clock设置界面02" />
<img src="/images/clock_settings_03.png" width="24%" alt="clock设置界面03" />

#### 整体结构

<img src="/images/deskclock_construction.png" width="80%" alt="clock结构图" /><br>
　　在DeskClock中，共有四个大功能，分别是AlarmClock（闹钟），Clock（时钟、世界时钟），Timer（定时器），Stopwatch（计时器、毫秒计时器），并且它们都继承于DeskClockFragment.java，具体功能实现各不相同，下面先以AlarmClock进行分析。

#### AlarmClock（闹钟）
　　*创建新的闹钟*<br>
　　点击新增按钮（DeskClock.java.mFab）---->
```Java
        mFab.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                getSelectedDeskClockFragment().onFabClick(mFab);
                //获取当前显示的Fragment调用其对应的onFabClick()方法
            }
        });
```
```Java
        for (int i = 0; i < mFragmentTabPagerAdapter.getCount(); i++) {
            final DeskClockFragment fragment = mFragmentTabPagerAdapter.getDeskClockFragment(i);
            if (fragment.isTabSelected()) {
                return fragment;
            }
        }
```
 　　---->调用AlarmClockFragment.java.onFabClick()
```Java
    @Override
    public void onFabClick(@NonNull ImageView fab) {
        mAlarmUpdateHandler.hideUndoBar();//隐藏底部消息弹窗
        startCreatingAlarm();//调用创建Alarm方法
    }
```
　　---->startCreatingAlarm()---->TimePickerDialogFragment.show(this)<br>
　　在调用时间选择器之前会将当前选中的Alarm置null，在创建好Alarm之后会选中为该Alarm。
```Java
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
            final OnTimeSetListener listener = ((OnTimeSetListener) getParentFragment());
      ...
                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            listener.onTimeSet(TimePickerDialogFragment.this,
                                    timePicker.getCurrentHour(), timePicker.getCurrentMinute());
                                    //listener = Fragment？因为AlarmClockFragment实现了TimePickerDialogFragment的内部接口OnTimeSetListener
                                    //在这里通过接口回调onTimeSet()方法将时间数据传递回AlarmClockFragment
                        }
                    }).setNegativeButton(android.R.string.cancel, null /* listener */)
                    .create();
      ...
    }

```
```Java
    @Override
    public void onTimeSet(TimePickerDialogFragment fragment, int hourOfDay, int minute) {
        mAlarmTimeClickHandler.onTimeSet(hourOfDay, minute);
    }
    
    //AlarmTimeClickHandler.onTimeSet方法
    public void onTimeSet(int hourOfDay, int minute) {
        if (mSelectedAlarm == null) {
            //由于前面已经设置为null，所以走这里的代码
            // If mSelectedAlarm is null then we're creating a new alarm.
            final Alarm a = new Alarm();
            a.hour = hourOfDay;
            a.minutes = minute;
            a.enabled = true;
            mAlarmUpdateHandler.asyncAddAlarm(a);
            //更新数据
        } else {
            //如果是修改已有的Alarm就不会设置为null，将走下面的代码
            mSelectedAlarm.hour = hourOfDay;
            mSelectedAlarm.minutes = minute;
            mSelectedAlarm.enabled = true;
            mScrollHandler.setSmoothScrollStableId(mSelectedAlarm.id);
            //这里设置了下一次更新数据后，ui中装Alarm的Recyclerview将滚动到指定的item，默认为-1，滚动结束后重新设置为-1
            mAlarmUpdateHandler.asyncUpdateAlarm(mSelectedAlarm, true, false);
            //更新数据
            mSelectedAlarm = null;
        }
    }
```
　　这里mScrollHandl实际上是AlarmClockFragment自身，在AlarmClockFragment中初始化AlarmTimeClickHandler时，构造方法最后一个参数传了this，而该参数被赋值给了mScrollHandler。回到AlarmClockFragment.java，可以发现，它确实实现了ScrollHandler接口。
<br>

  
  　　
　　
 
