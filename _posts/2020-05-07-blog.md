---
layout: post
title: JVM、(DVM)Dalvik和ART理解
categories: Android系统
description: 理解JVM、Dalvik和ART的联系和区别。
keywords: Android系统

---

## 理解JVM、Dalvik和ART的联系和区别。

### JVM
#### JVM内存模型

类装载子系统-----（类文件等）不包含于JVM内部结构<br>
运行期数据区-----（方法区、Java堆、Java栈、程序计数器、本地方法栈）<br>
执行引擎-----和运行期数据区、本地方法交互<br>
本地方法库----和执行引擎、运行期数据区交互<br>

#### Java类的生命周期

Java文件被编译后生成Class文件，这种二进制文件不依赖于特定的硬件和操作系统。每一个Class文件都对应着<br>
唯一的一个Java文件（或者接口）。JVM识别并执行Class文件，也就是说，任一语言，只要能编译成Class文件都能被
JVM认可。<br>

##### 加载----查找并加载Class文件
##### 链接----验证（确保导入类型的正确性）、准备（为类的静态字段分配字段并使用该默认值初始化该字段）、解析（将常量池内的符号引用替换为直接引用）
##### 初始化----将类变量初始化为正确的初始值
##### 使用
##### 卸载

#### 程序计数器
为保证程序能够连续的执行下去，处理器必须具有某些手段来确定下一条指令的地址。程序计数器就起到了这个作用。程序计数器（Program Counter Register）<br>
也叫作PC寄存器，是一块较小的内存空间。在虚拟机概念模型中，字节码解释器的工作就是通过改变程序计数器来选取下一条需要执行的字节码指令。Java虚拟机的多<br>
线程是通过轮流切换并分配处理器执行时间的方式来实现的，在一个确定的时刻只有一个处理器执行一条线程中的指令，为了线程在切换后能回复到正确的执行为止，<br>
每个线程都会有一个独立的程序计数器。因此，程序计数器是线程私有的。<br>
程序计数器是Java虚拟机规范中唯一没有规定OutOfMemoryError情况的数据区域。<br>

#### Java栈
每一条Java虚拟机线程都有一个线程私有的Java虚拟机栈（Java Virtual Machine Stacks）。它的生命周期与线程相同。Java虚拟机栈储存线程中的Java方法
<br>
调用的状态，包括局部变量、参数、返回值以及运算的中间结果。一个Java虚拟机栈包括多个栈帧，一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等
<br>
信息。当线程调用一个Java方法的时候，虚拟机压入一个新的栈帧到该线程的Java虚拟机栈中，当该方法执行完成后，这个栈帧就从java虚拟机栈中弹出。
<br>
如果线程请求分配的栈容量超过Java虚拟机所允许的最大容量，会抛出StackOverflowError。<br>
如果Java虚拟机栈可以动态扩展但是无法申请到足够的内存，或者没有足够的内存去创建对应的Java虚拟机栈，则会抛出OutOfMemoryError。<br>

#### Java堆
Java堆（Java Heap）是被所有线程共享的运行时内存区域。Java堆用来存放对象实例，几乎所有的对象实例都会在这里分配内存。Java堆存储<br>
的对象被垃圾收集器管理，这些受管理的对象无法显示的销毁。<br>

#### 本地方法栈
Java虚拟机实现可能需要C Stack来支持Native语言，这个C stack就是本地方法栈（Native Method Stack）。与虚拟机栈类似，只不过本地方法栈是用来支持Native层。<br>

#### 方法区
方法区（Method Area）是被所有线程共享的运行时内存区域。用来存储已经被Java虚拟机加载的类的结构信息，包括运行时常量池、字段、方法信息、静态变量等数据。<br>
方法区是Java堆的逻辑组成部分，在物理上不需要连续，并且可以选择在方法区中不识闲垃圾收集。

### DVM
#### DVM于JVM的区别
1. 基于的架构不同<br>
JVM基于栈，意味着需要去战中读写数据，所以需要的指令会更多，这样会导致速度变慢，对于性能有限的移动设备显然不合适。<br>
DVM基于寄存器，没有基于栈的虚拟机在复制数据时而使用的大量的出入栈的指令，其指令更为紧凑简洁。但是由于显式定义了操作数<br>
所以基于寄存器的指令会比基于栈的指令要大。<br>
2. 执行字节码不同<br>
JVM中java；类被编译成一个或者多个class文件，并打包成.jar文件，而后JVM通过相应的class文件和.jar文件获取相应字节码。
<br>
而DVM会用dx工具把所有的class文件打包成一个.dex文件，然后DVM会从该.dex文件中读取指令及数据。这个.dex文件将<br>
<br>
所有的class文件里所包含的信息全部整合到一起，这样加载起来会提高速度。
<br>
3. DVM允许钻有限的内存中同事运行多个进程<br>
DVM经过优化，允许在有限的内存中同时进行多个进程。在Android中给每一个应用都运行在一个DVM实例中，每一个实例都运行在<br>
一个独立的空间中，独立的进程可以防止虚拟机崩溃，导致所有的程序都被关闭。<br>
4. DVM由Zygote创建并初始化<br>
Zygote是一个DVM进程，同时也用来创建和初始化其他DVM进程。每当系统需要一个应用进程的时候，Zygote就会fork自身来快速的<br>
创建一个DVM进程，用于程序的运行。对于只读的系统库，所有的DVM实例都会和Zygote共享一块内存区域以节省内存开销。
5. DVM有共享机制<br>
DVM拥有预加载-共享机制，不同应用之间运行时可以共享相同的类，拥有更高的效率。而JVM机制不存在这种共享机制。<br>
打包以后程序都是独立的，即便是会使用相同的类，运行时也是单独加载和运行的。<br>
6. DVM早期没有JIT（Just In Time Compiler）<br>
JVM使用了JIT，但早期的JVM并没有使用JIT编译器。<br>
早期的DVM执行代码都需要用解释器将dex代码编译成机器码，然后交给系统处理，效率并不高。在Android2.2之后，开始为DVM是用来JIT<br>
JIT会对需要多次运行的代码（热代码）进行编译，生成相当精简的本地机器码（Native Code），这样在下次执行到相同的逻辑时，可以直接使用<br>
编译好的机器码。不过，在每次程序重新运行的时候，都需要重复一次热代码编译成机器码的操作。<br>

### ART虚拟机
ART（Android Runtime）是在Android4.4发布的，用来替换Dalvik虚拟机。Android4.4默认为DVM，可以在开发者选项中切换为ART<br>
5.0之后完全替换，DVM从此退出了历史舞台。<br>
在DVM中，class字节码文件需要在每次运行时编译为机器码，这样会使应用程序的运行效率降低，尽管JIT会对热代码进行编译，但是显然效率依旧不高<br>
在ART中，系统安装应用程序时，会进行一次预编译(AOT:ahead of time compilation)，将字节码编译成机器码并存储在本地，这样应用程序运行时<br>
不再需要编译，大大提高了效率。但是AOT并不完美，一是AOT会使应用安装时间变长，尤其是复杂的应用；二是编译成机器码后应用所需存储空间会增大<br>
因此，在Android 7.0中，ART加入了JIT，作为AOT的一个补充，应用程序安装时不会将class文件全部编译成机器码，热点代码会在系统运行时编译成<br>
机器码，从而缩短程序安装时间，并节省内存。<br>
<br>
DVM针对32位CPU设计，而ART支持64位并且兼容32位CPU，这也是DVM被淘汰的一个重要原因。
<br>
ART对垃圾回收机子进行了改进，更频繁的执行并行垃圾收集，将GC暂停次数由2减少为1<br>
此外，ART运行时堆空间划分和DVM也有不同。<br>
#### ART垃圾回收
DVM的垃圾回收算法采用的是标记-清除算法（Mark-Sweep），ART改进了该算法并使用了多种垃圾收集器。<br>
1. Concurrent Mark Sweep（CMS）：CMS收集器是一种获取最短收集暂停时间为目标的收集器，采用了<br>
标记-清除算法实现。是一个完整的堆垃圾收集器。<br>
2. Concurrent Partial Mark Sweep：部分完整的堆垃圾收集器。<br>
3. Concurrent Sticky Mark Sweep:粘性收集器，基于分代垃圾收集思想，只能释放上次GC之后分配的对象。<br>
该收集器扫描十分频繁，因为更快且暂停时间更短。
<br>
4. Marksweep+Semispace：非并发GC，复制GC用于堆转换及齐性空间压缩（碎片整理）。<br>



                                                                   
  

