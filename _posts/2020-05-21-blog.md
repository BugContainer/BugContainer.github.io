---
layout: post
title: Kotlin MVVM酷欧天气完整解析
categories: Kotlin
description: 以酷欧天气为基石分析Kotlin的MVVM实现
keywords: Kotlin, MVVM
---

以酷欧天气为基石分析Kotlin的MVVM实现

#### 附上Kotlin版本酷欧天气github地址
> https://github.com/guolindev/coolweatherjetpack

### 配置文件build.gradle（app）

> apply plugin: 'kotlin-android'

*使用Kotlin需要添加<br>*

> apply plugin: 'kotlin-android-extensions'

*替代findViewById,在Activity中 import kotlinx.android.synthetic.main.activity_main.\* 之后就可直接通过控件名称获取对应控件。*<br>

> apply plugin: 'kotlin-kapt'

*如果你的Kotlin代码里面有使用到注解，那么需要加入这个插件（kapt 即 Kotlin annotation processing tool，Kotlin 注解处理工具的缩写）*<br>

　　**要使用dataBinding需要在android{...}中启用**<br>
```Java
    dataBinding {
        enabled true
    }
```
　　**添加项目依赖**
```Java
    //Litepal数据库
    implementation 'org.litepal.android:kotlin:3.0.0'
    //retrofit网络请求
    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
    //gson转换器
    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
    //scalars转换器
    implementation 'com.squareup.retrofit2:converter-scalars:2.5.0'
    //glide图片加载
    implementation 'com.github.bumptech.glide:glide:3.7.0'
    //google ViewModel +LiveData 依赖官方引入方式
    def lifecycle_version = "2.0.0"
    // ViewModel and LiveData  直接改为2.0.0也ok
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
```
### MainActivity
　　MainActivity中只有一个onCreate方法
```Java
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        //通过ViewModelProviders.of()方法传入factory获取对应的ViewModelProvider实例，然后通过实例获取到指定的ViewModel
        val viewModel = ViewModelProviders.of(this, InjectorUtil.getMainModelFactory()).get(MainViewModel::class.java)
        // MainViewModel     fun isWeatherCached() = repository.isWeatherCached() 
        // WeatherRepository     fun isWeatherCached() = weatherDao.getCachedWeatherInfo() != null
        // WeatherDao  通过val weatherInfo = PreferenceManager.getDefaultSharedPreferences
        // (CoolWeatherApplication.context).getString("weather", null)查询sp中是否有天气缓存信息，不存在返回null
        // 如果存在则通过gson解析数据返回
        if (viewModel.isWeatherCached()) {
            //如果数据已缓存，启动WeatherActivity,结束当前Activity
            val intent = Intent(this, WeatherActivity::class.java)
            startActivity(intent)
            finish()
        } else {
            //如果没有缓存数据activity_mian中添加fragment，切换为ChooseAreaFragment
            supportFragmentManager.beginTransaction().replace(R.id.container, ChooseAreaFragment).commit()
        }
    }
```
　　### ChooseAreaFragment
　　Kotlin中有两种延迟初始化的方式。一种是lateinit var，一种是by lazy。<br>
*lateinit*<br>
　　lateinit var只能用来修饰类属性，不能用来修饰局部变量，并且只能用来修饰对象，不能用来修饰基本类型(因为基本类型的属性在类加载后的准备阶段都会被初始化为默认值)。<br>
  lateinit var的作用也比较简单，就是让编译期在检查时不要因为属性变量未被初始化而报错。
*by lazy*<br>
　　by lazy本身是一种属性委托。属性委托的关键字是by。<br>
　　by lazy要求属性声明为val，即不可变变量，在java中相当于被final修饰。<br>
  这意味着该变量一旦初始化后就不允许再被修改值了(基本类型是值不能被修改，对象类型是引用不能被修改)。{}内的操作就是返回唯一一次初始化的结果。<br>
  by lazy可以使用于类属性或者局部变量。<br>
```Java
    private val viewModel by lazy { ViewModelProviders.of(this, InjectorUtil.getChooseAreaModelFactory()).get(ChooseAreaViewModel::class.java) }
```
  
  
  
